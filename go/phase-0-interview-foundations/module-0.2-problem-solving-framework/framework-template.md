# 10-Step Problem-Solving Framework - Quick Reference

Use this template when solving any algorithmic problem. Copy this structure and fill in details for each problem you encounter.

---

## Problem: [Problem Name]

**Source**: [LeetCode/HackerRank/Interview/etc.]  
**Difficulty**: [Easy/Medium/Hard]  
**Date**: [Date]

---

### Step 1: Understand the Problem

**Problem Statement** (in my own words):


**Input**:
- Type: 
- Constraints: 

**Output**:
- Type: 
- Format: 

**Core Question**:


---

### Step 2: Clarify Constraints and Edge Cases

**Questions to Ask**:
- [ ] Can input be nil/empty?
- [ ] What are the size limits?
- [ ] What are the value ranges?
- [ ] Are there special cases to handle?
- [ ] What should be returned for invalid input?

**Constraints**:
- 
- 
- 

**Edge Cases to Consider**:
- 
- 
- 

---

### Step 3: Generate Examples

**Example 1** (Normal Case):
```
Input: 
Output: 
Explanation: 
```

**Example 2** (Edge Case):
```
Input: 
Output: 
Explanation: 
```

**Example 3** (Complex Case):
```
Input: 
Output: 
Explanation: 
```

---

### Step 4: Identify Patterns and Data Structures

**Similar Problems I've Seen**:
- 
- 

**Applicable Patterns**:
- [ ] Two Pointers
- [ ] Sliding Window
- [ ] Hash Map/Set
- [ ] Stack/Queue
- [ ] Binary Search
- [ ] DFS/BFS
- [ ] Dynamic Programming
- [ ] Backtracking
- [ ] Other: 

**Data Structures Needed**:
- 
- 

**Why These Choices**:


---

### Step 5: Develop Brute Force Approach

**Approach Description**:


**Algorithm**:
```
1. 
2. 
3. 
```

**Complexity**:
- Time: 
- Space: 

**Why This Works**:


---

### Step 6: Optimize the Solution

**Bottleneck Identified**:


**Optimization Strategy**:


**Optimized Approach**:


**Optimized Algorithm**:
```
1. 
2. 
3. 
```

**Optimized Complexity**:
- Time: 
- Space: 

**Why This is Better**:


**Is This Optimal?**: [ ] Yes [ ] No

**Reasoning**:


---

### Step 7: Walk Through Algorithm with Example

**Example**: 

**Step-by-Step Execution**:
```
Initial State: 

Iteration 1:
  State: 
  Action: 
  Result: 

Iteration 2:
  State: 
  Action: 
  Result: 

...

Final Result: 
```

**Verification**: [ ] Output matches expected

---

### Step 8: Implementation

```go
// Implementation goes here
```

**Code Quality Checklist**:
- [ ] Meaningful variable names
- [ ] Clear code structure
- [ ] Appropriate comments
- [ ] Edge cases handled
- [ ] Follows idiomatic Go (e.g., error handling, zero values)

---

### Step 9: Test with Examples

**Test Case 1**:
```
Input: 
Expected: 
Actual: 
Status: [ ] Pass [ ] Fail
```

**Test Case 2**:
```
Input: 
Expected: 
Actual: 
Status: [ ] Pass [ ] Fail
```

**Test Case 3**:
```
Input: 
Expected: 
Actual: 
Status: [ ] Pass [ ] Fail
```

**Edge Case Tests**:
```
Input: 
Expected: 
Actual: 
Status: [ ] Pass [ ] Fail
```

**All Tests Passing**: [ ] Yes [ ] No

**Bugs Found and Fixed**:
- 
- 

---

### Step 10: Analyze Complexity and Discuss Tradeoffs

**Final Time Complexity**: 

**Explanation**:


**Final Space Complexity**: 

**Explanation**:


**Tradeoffs**:
| Approach | Time | Space | Pros | Cons |
|----------|------|-------|------|------|
| Brute Force | | | | |
| Optimized | | | | |

**Alternative Approaches**:
- 
- 

**When to Use Each**:


**Follow-up Questions to Consider**:
- 
- 

---

## Reflection

**What Went Well**:


**What I Struggled With**:


**Key Learnings**:


**Similar Problems to Practice**:
- 
- 
- 

---

**Status**: [ ] Solved [ ] Need to Review [ ] Mastered

**Review Date**: _______________
