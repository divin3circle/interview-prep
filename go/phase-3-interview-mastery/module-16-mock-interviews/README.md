# Module 16: Mock Interviews

## Purpose
Mock interviews simulate the pressure of the real thing. It is the single most effective way to improve.

## Mock Interview Rubric (Score 1-4)

### 1. Communication
- [ ] Did the candidate clarify the problem?
- [ ] Did they clearly explain their approach *before* coding?
- [ ] Did they listen to hints?

### 2. Problem Solving
- [ ] Did they find an optimal solution?
- [ ] Did they consider edge cases (nil, empty, negative)?
- [ ] Can they analyze Time/Space complexity accurately?

### 3. Coding (Go-Specific)
- [ ] Is the code syntactically correct?
- [ ] Are variable names descriptive and idiomatic?
- [ ] Is the code DRY (Don't Repeat Yourself)?
- [ ] Do they follow Go conventions (exported/unexported, error handling)?

## Go Interview Tips
- **Mention Go idioms**: "I'm using a slice here for dynamic sizing" or "I'll use defer for cleanup"
- **Error handling**: Acknowledge where you'd add error handling in production
- **Concurrency**: If relevant, mention goroutines/channels (but only if asked)
- **Standard library**: Reference `container/heap`, `sort`, `strings` packages when appropriate

## Behavioral (STAR Method)
**S**ituation: Context.
**T**ask: What was the goal?
**A**ction: What did YOU do specifically? (Use "I", not "We").
**R**esult: Quantifiable outcome (Saved 20%, Increased speed 2x).

**Common Questions**:
1. Tell me about a time you failed.
2. Tell me about a conflict with a coworker.
3. Describe a challenging technical problem you solved.
4. Why Go? (Be ready to discuss: simplicity, concurrency, performance, tooling)

## Practice Resources
- **LeetCode**: Filter by Go, practice explaining solutions
- **Pramp**: Free peer mock interviews
- **Interviewing.io**: Anonymous technical interviews
- **Go-specific**: Practice implementing common patterns without IDE assistance
