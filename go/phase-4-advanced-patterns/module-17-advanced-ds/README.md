# Module 17: Advanced Data Structures

## Tries (Prefix Trees)
Used for autocomplete and spell checkers.

### Go Implementation
```go
type TrieNode struct {
    children map[rune]*TrieNode
    isEnd    bool
}

type Trie struct {
    root *TrieNode
}

func NewTrie() *Trie {
    return &Trie{root: &TrieNode{children: make(map[rune]*TrieNode)}}
}

func (t *Trie) Insert(word string) {
    node := t.root
    for _, ch := range word {
        if _, exists := node.children[ch]; !exists {
            node.children[ch] = &TrieNode{children: make(map[rune]*TrieNode)}
        }
        node = node.children[ch]
    }
    node.isEnd = true
}
```

**Complexity**: Insert O(L), Search O(L), Space O(ALPHABET_SIZE * L * N)

## Union-Find (Disjoint Set)
Used for network connectivity, Kruskal's Algorithm, cycle detection.

### Go Implementation
```go
type UnionFind struct {
    parent []int
    rank   []int
}

func NewUnionFind(n int) *UnionFind {
    parent := make([]int, n)
    rank := make([]int, n)
    for i := range parent {
        parent[i] = i
    }
    return &UnionFind{parent: parent, rank: rank}
}

func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.Find(uf.parent[x]) // Path compression
    }
    return uf.parent[x]
}

func (uf *UnionFind) Union(x, y int) bool {
    rootX, rootY := uf.Find(x), uf.Find(y)
    if rootX == rootY {
        return false
    }
    // Union by rank
    if uf.rank[rootX] < uf.rank[rootY] {
        uf.parent[rootX] = rootY
    } else if uf.rank[rootX] > uf.rank[rootY] {
        uf.parent[rootY] = rootX
    } else {
        uf.parent[rootY] = rootX
        uf.rank[rootX]++
    }
    return true
}
```

**Optimization**: Path Compression + Union by Rank → O(α(N)) (effectively O(1))

## Segment Trees
Used for range queries (Sum, Min, Max) with updates.

**Complexity**: Build O(n), Query O(log n), Update O(log n)

### Go Note
For most interview problems, simpler approaches (prefix sums, sparse tables) are preferred. Mention segment trees conceptually but implement simpler solutions unless specifically required.
