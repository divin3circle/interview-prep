# Phase 2: Core Patterns + Blind 75

## Overview

Phase 2 represents the core of this technical interview preparation course. This phase systematically teaches essential algorithmic patterns through the Blind 75 curated problem set, a collection of problems that covers the most important concepts and techniques for technical interviews.

**Duration**: Variable (recommend 8-12 weeks for thorough mastery)  
**Modules**: 12  
**Total Problems**: 45+  
**Prerequisites**: Phase 0 and Phase 1 completion

## Learning Objectives

By completing Phase 2, you will:

- Master 12 fundamental algorithmic patterns
- Solve all Blind 75 problems with optimal solutions
- Recognize problem patterns instantly during interviews
- Apply the 10-step framework consistently
- Communicate solutions clearly and professionally
- Analyze time and space complexity accurately
- Handle edge cases systematically

## Why Blind 75?

The Blind 75 is a curated list of essential LeetCode problems created by a former Facebook engineer. These problems:

- Cover all fundamental patterns needed for technical interviews
- Appear frequently at top technology companies
- Build upon each other to reinforce learning
- Represent optimal use of preparation time
- Balance breadth and depth of coverage

## Module Structure

Each module follows this format:

1. **Pattern Introduction**: Explanation of the pattern and when to use it
2. **Pattern Summary**: Quick reference guide
3. **Problems**: 2-6 problems demonstrating the pattern
4. **Each Problem Includes**:
   - Problem statement with examples and constraints
   - Optimal solution with detailed comments
   - Step-by-step explanation using the 10-step framework
   - Comprehensive test cases
   - Variations and follow-up questions

## Modules Overview

### Module 3: Arrays & Hashing (6 problems)
**Duration**: 1 week  
**Pattern**: Using hash maps and sets for O(1) lookups

Problems:
- Contains Duplicate
- Two Sum
- Valid Anagram
- Group Anagrams
- Top K Frequent Elements
- Product of Array Except Self

[Start Module 3](module-3-arrays-hashing/README.md)

---

### Module 4: Two Pointers (5 problems)
**Duration**: 1 week  
**Pattern**: Using two pointers to traverse arrays efficiently

Problems:
- Valid Palindrome
- Two Sum II - Input Array Is Sorted
- 3Sum
- Container With Most Water
- Trapping Rain Water

[Start Module 4](module-4-two-pointers/README.md)

---

### Module 5: Sliding Window (4 problems)
**Duration**: 1 week  
**Pattern**: Maintaining a window of elements for subarray problems

Problems:
- Best Time to Buy and Sell Stock
- Longest Substring Without Repeating Characters
- Longest Repeating Character Replacement
- Minimum Window Substring

[Start Module 5](module-5-sliding-window/README.md)

---

### Module 6: Stack (6 problems)
**Duration**: 1 week  
**Pattern**: Using stacks for nested structures and monotonic sequences

Problems:
- Valid Parentheses
- Min Stack
- Evaluate Reverse Polish Notation
- Daily Temperatures
- Car Fleet
- Largest Rectangle in Histogram

[Start Module 6](module-6-stack/README.md)

---

### Module 7: Binary Search (4 problems)
**Duration**: 1 week  
**Pattern**: Searching sorted spaces in O(log n) time

Problems:
- Binary Search
- Search in Rotated Sorted Array
- Find Minimum in Rotated Sorted Array
- Search a 2D Matrix

[Start Module 7](module-7-binary-search/README.md)

---

### Module 8: Linked Lists (6 problems)
**Duration**: 1 week  
**Pattern**: Manipulating linked list pointers

Problems:
- Reverse Linked List
- Merge Two Sorted Lists
- Reorder List
- Remove Nth Node From End of List
- Linked List Cycle
- Add Two Numbers

[Start Module 8](module-8-linked-lists/README.md)

---

### Module 9: Trees - DFS & BFS (6 problems)
**Duration**: 1 week  
**Pattern**: Tree traversal using recursion and queues

Problems:
- Maximum Depth of Binary Tree
- Same Tree
- Subtree of Another Tree
- Invert Binary Tree
- Lowest Common Ancestor of a Binary Search Tree
- Binary Tree Level Order Traversal

[Start Module 9](module-9-trees-dfs-bfs/README.md)

---

### Module 10: Binary Search Trees (2 problems)
**Duration**: 3-4 days  
**Pattern**: Leveraging BST properties for efficient operations

Problems:
- Validate Binary Search Tree
- Kth Smallest Element in a BST

[Start Module 10](module-10-bst/README.md)

---

### Module 11: Heaps / Priority Queue (2 problems)
**Duration**: 3-4 days  
**Pattern**: Using heaps for top-K and median problems

Problems:
- Kth Largest Element in an Array
- Find Median from Data Stream

[Start Module 11](module-11-heaps/README.md)

---

### Module 12: Backtracking (4 problems)
**Duration**: 1 week  
**Pattern**: Exploring all possibilities with pruning

Problems:
- Subsets
- Permutations
- Combination Sum
- Word Search

[Start Module 12](module-12-backtracking/README.md)

---

### Module 13: Graphs (4 problems)
**Duration**: 1 week  
**Pattern**: Graph traversal and cycle detection

Problems:
- Number of Islands
- Clone Graph
- Pacific Atlantic Water Flow
- Course Schedule

[Start Module 13](module-13-graphs/README.md)

---

### Module 14: Dynamic Programming (6 problems)
**Duration**: 2 weeks  
**Pattern**: Breaking problems into overlapping subproblems

Problems:
- Climbing Stairs
- House Robber
- Coin Change
- Longest Increasing Subsequence
- Word Break
- Unique Paths

[Start Module 14](module-14-dynamic-programming/README.md)

---

## Study Approach

### Recommended Sequence

1. **Complete modules in order**: Each module builds upon previous concepts
2. **Master one pattern before moving on**: Ensure deep understanding
3. **Solve all problems in a module**: Repetition builds pattern recognition
4. **Review previous modules periodically**: Spaced repetition enhances retention

### For Each Problem

1. **Read problem statement carefully**: Understand requirements fully
2. **Apply the 10-step framework**: Use systematic approach
3. **Code solution independently**: Resist looking at solution immediately
4. **Compare with provided solution**: Learn optimization techniques
5. **Study the explanation**: Understand the reasoning
6. **Test with edge cases**: Verify correctness
7. **Solve variations**: Deepen understanding

### Time Management

**Minimum**: 1 problem per day (12 weeks total)  
**Recommended**: 2-3 problems per day (6-8 weeks total)  
**Intensive**: 5+ problems per day (3-4 weeks total)

**Note**: Quality over quantity. Better to deeply understand one problem than superficially solve five.

## Pattern Recognition Guide

Learning to recognize patterns is crucial for interview success. For each new problem, ask:

1. **Is the array sorted?** → Consider binary search or two pointers
2. **Need to find pairs/triplets?** → Consider hash map or two pointers
3. **Subarray/substring problem?** → Consider sliding window
4. **Nested structure?** → Consider stack
5. **Tree problem?** → Consider DFS (recursion) or BFS (queue)
6. **Optimization problem?** → Consider dynamic programming
7. **All possibilities?** → Consider backtracking
8. **Graph connectivity?** → Consider DFS/BFS or Union Find

## Completion Criteria

You have successfully completed Phase 2 when you can:

- [ ] Solve any Blind 75 problem independently within 30-45 minutes
- [ ] Identify the pattern for a new problem within 2-3 minutes
- [ ] Explain your solution clearly and professionally
- [ ] Analyze time and space complexity accurately
- [ ] Handle edge cases systematically
- [ ] Optimize from brute force to optimal solution
- [ ] Write clean, production-quality code

## Progress Tracking

- [ ] Module 3: Arrays & Hashing (6/6 problems)
- [ ] Module 4: Two Pointers (5/5 problems)
- [ ] Module 5: Sliding Window (4/4 problems)
- [ ] Module 6: Stack (6/6 problems)
- [ ] Module 7: Binary Search (4/4 problems)
- [ ] Module 8: Linked Lists (6/6 problems)
- [ ] Module 9: Trees - DFS & BFS (6/6 problems)
- [ ] Module 10: Binary Search Trees (2/2 problems)
- [ ] Module 11: Heaps / Priority Queue (2/2 problems)
- [ ] Module 12: Backtracking (4/4 problems)
- [ ] Module 13: Graphs (4/4 problems)
- [ ] Module 14: Dynamic Programming (6/6 problems)

## Next Steps

After completing Phase 2, proceed to [Phase 3: Interview Mastery](../phase-3-interview-mastery/README.md) to refine your communication skills and practice mock interviews.

## Additional Resources

- [Pattern Recognition Cheatsheet](../resources/cheatsheets/pattern-recognition-guide.md)
- [Complexity Quick Reference](../resources/cheatsheets/complexity-quick-reference.md)
- [Solution Template](../resources/templates/solution-template.java)

---

**This phase represents the core value of this course. Mastering these patterns and problems will prepare you for technical interviews at any company.**
